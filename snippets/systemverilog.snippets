snippet always  always @ ..
	always @(${1:posedge clk}) begin
	    ${2}
	end
snippet always  always_comb ..
	always_comb begin
	    ${1}
	end
snippet always_comb  always_comb ..
	always_comb begin
	    ${1}
	end
snippet always  always_ff ..
	always_ff @(${1:posedge clk or negedge reset_n})
	    ${2}
	end
snippet always_ff  always_ff ..
	always_ff @(${1:posedge clk or negedge reset_n})
	    ${2}
	end
snippet always  always_latch ..
	always_latch
	    ${1}
	end
snippet always_latch  always_latch ..
	always_latch
	    ${1}
	end
snippet case  case() .. 
	case(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet case  casex() .. 
	casex(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet casex  casex() .. 
	casex(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet case  casez() .. 
	casez(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet casez  casez() .. 
	casez(${1:expression})
	    ${2:value1}: begin
	       ${3}
	    end
	
	    // other case branches
	
	    default: begin
	
	    end
	endcase
snippet class  class .. endclass
	class ${1:class_name} extends ${2:base_class};
	    ${4}
	    function new(${3:args});
	        super.new($3);
	
	    endfunction: new
	
	endclass: $1
snippet clocking  clocking .. { .. }
	clocking ${1:name_cb} @(posedge ${2:clock});
	    default input #${3:setup_time} output #${4:hold_time};
	    ${5}
	    // output declarations
	    // input declarations
	endclocking: $1
snippet do  do .. while()
	do begin
	    ${2}
	end while($1);
snippet enum  enum .. { .. }
	typedef enum {${2}
		      } ${1:name_e};
snippet final  final ..
	final begin
	    ${1}
	end
snippet for  for() .. 
	for(${1:int i = 0}; ${2:i <= n}; ${3:i++}) begin
	    ${4}
	end
snippet foreach  foreach(x[i]) ..
	foreach(${1:x}[i]) begin
	    ${2}
	end
snippet forever  forever .. 
	forever begin
	    ${1}
	end
snippet fork  fork .. join
	fork
	    begin
	        ${1}
	    end
	    begin
	
	    end
	join
snippet fork  fork .. join_any
	fork
	    begin
	        ${1}
	    end
	    begin
	
	    end
	join_any
snippet fork  fork .. join_none
	fork
	    begin
	        ${1}
	    end
	    begin
	
	    end
	join_none
snippet function  function .. endfunction
	function ${1:void} ${2:function_name} ($3);
	    ${4}
	endfunction: $2
snippet cover  covergroup .. endgroup
	covergroup ${1:function_name};
	    ${2}
	endgroup: $1
snippet if  if() .. 
	if(${1:condition}) begin
	    ${2}
	end
snippet ife  if() .. else
	if(${1:condition}) begin
	    ${2}
	end
	else begin
	    ${3}
	end
snippet initial  initial ..
	initial begin
	    ${1}
	end
snippet interface  interface .. { .. }
	// vmm rule 4-4 -- interfaces shall be packaged into the same files as the
	// transactors that use them
	interface ${1:name_if} (// input wire clk,
			     // input wire reset
			     );
	    timeunit 1ns;
	    timeprecision 100ps;
	
	    ${2}
	    // imports
	    // import pkg::*;
	
	    parameter hold_time = 2;     // timeunit is 1ns
	    parameter setup_time = 2;    // change timing values as per requirement
	
	    // Clocking Blocks
	    // just type clocking and tab to invoke snippet
	
	    // Modports
	    // just type modport and tab to invoke snippet
	
	endinterface: $1
snippet modport  modport .. { .. }
	modport ${1:name_mp}
	    (${2}
	     // clocking clocking_cb,
	     // input input_name,
	     // output output_port,
	     // ....
	     );
snippet module  module .. endmodule
	module ${1:module_name} (/*port details*/);
	    ${2}
	endmodule: $1
snippet once  `ifndef XXX; `define XXX; `endif
	\`ifndef ${1:`toupper('_'.substitute(expand('%:t'), '\.', '_', '').'_')`}
	
	\`define $1
	
	${2}
	
	\`endif // Guard
snippet package  package .. endpackage
	package ${1:package_name};
	    ${2}
	endpackage: $1
snippet parameter  parameter .. 
	parameter ${1:param_name} = ${2:param_value};
	${3}
snippet program  program .. { .. }
	program automatic ${1:name};
	    // declarations
	    ${2}
	
	    initial begin
	
	    end
	endprogram: $1
snippet randcase  randcase .. endcase
	randcase;
	    ${1:weight1}:
	        ${3}
	    ${2:weight2}:
	endcase
snippet repeat  repeat(N) ..
	repeat(${1:N}) begin
	    ${2}
	end
snippet struct  struct ... { ... }
	typedef struct {
	    ${2}
	    } ${1:name_s};
snippet task  task .. endtask
	task ${1:task_name} ($3);
	    ${2}
	endtask: $1
snippet typedef  typedef ..
	typedef ${1:type} ${2:type_name};
	${3}
snippet union  union ... { ... }
	typedef union {
	    ${2}
	} ${1:name_u};
snippet while  while() ..
	while (${1:condition}) begin
	    ${2}
	end
snippet ovm  OVM Agent
	class ${1:ovc_name}_agent extends ovm_agent;
	   ${3}
	   ovm_active_passive_enum is_active;
	   $1_sequencer sequencer;
	   $1_driver driver;
	   $1_monitor monitor;
	
	   \`ovm_component_utils_begin($1_agent)
	      \`ovm_field_enum(ovm_active_passive_enum, is_active, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      monitor=$1_monitor::type_id::create("monitor", this);
	      if (is_active == OVM_ACTIVE) begin
		 driver=$1_driver::type_id::create("driver", this);
		 sequencer=$1_sequencer::type_id::create("sequencer", this);
	      end
	   endfunction: build
	
	   virtual function void connect();
	      if (is_active == OVM_ACTIVE) begin
		 driver.seq_item_port.connect(sequencer.seq_item_export);
	      end
	   endfunction: connect
	
	   virtual function void assign_vif(virtual interface ${2:ovc_if} vif);
	      monitor.vif = vif;
	      if (is_active == OVM_ACTIVE) begin
		 driver.vif=vif;
	      end
	   endfunction: assign_vif
	
	endclass: $1_agent
snippet ovm_agent  OVM Agent
	class ${1:ovc_name}_agent extends ovm_agent;
	   ${3}
	   ovm_active_passive_enum is_active;
	   $1_sequencer sequencer;
	   $1_driver driver;
	   $1_monitor monitor;
	
	   \`ovm_component_utils_begin($1_agent)
	      \`ovm_field_enum(ovm_active_passive_enum, is_active, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      monitor=$1_monitor::type_id::create("monitor", this);
	      if (is_active == OVM_ACTIVE) begin
		 driver=$1_driver::type_id::create("driver", this);
		 sequencer=$1_sequencer::type_id::create("sequencer", this);
	      end
	   endfunction: build
	
	   virtual function void connect();
	      if (is_active == OVM_ACTIVE) begin
		 driver.seq_item_port.connect(sequencer.seq_item_export);
	      end
	   endfunction: connect
	
	   virtual function void assign_vif(virtual interface ${2:ovc_if} vif);
	      monitor.vif = vif;
	      if (is_active == OVM_ACTIVE) begin
		 driver.vif=vif;
	      end
	   endfunction: assign_vif
	
	endclass: $1_agent
snippet ovmagent  OVM Agent
	class ${1:ovc_name}_agent extends ovm_agent;
	   ${3}
	   ovm_active_passive_enum is_active;
	   $1_sequencer sequencer;
	   $1_driver driver;
	   $1_monitor monitor;
	
	   \`ovm_component_utils_begin($1_agent)
	      \`ovm_field_enum(ovm_active_passive_enum, is_active, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      monitor=$1_monitor::type_id::create("monitor", this);
	      if (is_active == OVM_ACTIVE) begin
		 driver=$1_driver::type_id::create("driver", this);
		 sequencer=$1_sequencer::type_id::create("sequencer", this);
	      end
	   endfunction: build
	
	   virtual function void connect();
	      if (is_active == OVM_ACTIVE) begin
		 driver.seq_item_port.connect(sequencer.seq_item_export);
	      end
	   endfunction: connect
	
	   virtual function void assign_vif(virtual interface ${2:ovc_if} vif);
	      monitor.vif = vif;
	      if (is_active == OVM_ACTIVE) begin
		 driver.vif=vif;
	      end
	   endfunction: assign_vif
	
	endclass: $1_agent
snippet ovm  OVM Data Item
	class ${1:ovc_item} extends ovm_sequence_item;
	   ${2}
	   /* AUTO_OVM_VARS */
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   
	   \`ovm_object_utils_begin(yapp_pkt)
	      \`ovm_field_int(addr, OVM_ALL_ON)
	      \`ovm_field_int(length, OVM_ALL_ON)
	      \`ovm_field_array_int(payload, OVM_ALL_ON)
	   \`ovm_object_utils_end
	
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet ovm_sequence_item  OVM Data Item
	class ${1:ovc_item} extends ovm_sequence_item;
	   ${2}
	   /* AUTO_OVM_VARS */
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   
	   \`ovm_object_utils_begin(yapp_pkt)
	      \`ovm_field_int(addr, OVM_ALL_ON)
	      \`ovm_field_int(length, OVM_ALL_ON)
	      \`ovm_field_array_int(payload, OVM_ALL_ON)
	   \`ovm_object_utils_end
	
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet ovm_data  OVM Data Item
	class ${1:ovc_item} extends ovm_sequence_item;
	   ${2}
	   /* AUTO_OVM_VARS */
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   
	   \`ovm_object_utils_begin(yapp_pkt)
	      \`ovm_field_int(addr, OVM_ALL_ON)
	      \`ovm_field_int(length, OVM_ALL_ON)
	      \`ovm_field_array_int(payload, OVM_ALL_ON)
	   \`ovm_object_utils_end
	
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet ovm_data_item  OVM Data Item
	class ${1:ovc_item} extends ovm_sequence_item;
	   ${2}
	   /* AUTO_OVM_VARS */
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   
	   \`ovm_object_utils_begin(yapp_pkt)
	      \`ovm_field_int(addr, OVM_ALL_ON)
	      \`ovm_field_int(length, OVM_ALL_ON)
	      \`ovm_field_array_int(payload, OVM_ALL_ON)
	   \`ovm_object_utils_end
	
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet ovm_item  OVM Data Item
	class ${1:ovc_item} extends ovm_sequence_item;
	   ${2}
	   /* AUTO_OVM_VARS */
	   rand bit [3:0] addr;
	   rand bit [5:0] length;
	   rand bit [7:0] payload [];
	   
	   \`ovm_object_utils_begin(yapp_pkt)
	      \`ovm_field_int(addr, OVM_ALL_ON)
	      \`ovm_field_int(length, OVM_ALL_ON)
	      \`ovm_field_array_int(payload, OVM_ALL_ON)
	   \`ovm_object_utils_end
	
	   function new(string name="$1");
	      super.new(name);
	   endfunction: new
	
	endclass: $1
snippet ovm  OVM Driver
	class ${1:ovc_name}_driver extends ovm_driver #(${2:ovc_item});
	   ${4}
	   string tID;
	   virtual interface ${3:ovc_if} vif;
	   $2 item;
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   \`ovm_component_utils_begin($1_driver)
	      \`ovm_field_object(item, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task get_and_drive();
	      forever
		begin
		   // wait(vif.reset==0);  // block until reset released
		   seq_item_port.get_next_item(item);
		   send_to_dut(item);
		   seq_item_port.item_done();
		end
	   endtask: get_and_drive
	
	   task send_to_dut(input $2 item);
	      ovm_report_info(tID, $psprintf("%s : item sent is %0s",
					     tID, item.sprint()), OVM_FULL);
	      // Send data to DUT (BFM - fill in your BFM code here)
	      #10 ;
	      #10 ;
	   endtask: send_to_dut
	
	   task reset_dut();
	      // fill in any reset code here
	   endtask: reset_dut
	
	   task run();
	      ovm_report_info(tID, $psprintf(" %s : running", tID), OVM_MEDIUM);
	      // reset_dut(); // fill in 'reset_dut()' if needed
	      get_and_drive();
	   endtask: run
	
	   virtual function void report();
	      // fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	endclass: $1_driver
snippet ovm_driver  OVM Driver
	class ${1:ovc_name}_driver extends ovm_driver #(${2:ovc_item});
	   ${4}
	   string tID;
	   virtual interface ${3:ovc_if} vif;
	   $2 item;
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   \`ovm_component_utils_begin($1_driver)
	      \`ovm_field_object(item, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task get_and_drive();
	      forever
		begin
		   // wait(vif.reset==0);  // block until reset released
		   seq_item_port.get_next_item(item);
		   send_to_dut(item);
		   seq_item_port.item_done();
		end
	   endtask: get_and_drive
	
	   task send_to_dut(input $2 item);
	      ovm_report_info(tID, $psprintf("%s : item sent is %0s",
					     tID, item.sprint()), OVM_FULL);
	      // Send data to DUT (BFM - fill in your BFM code here)
	      #10 ;
	      #10 ;
	   endtask: send_to_dut
	
	   task reset_dut();
	      // fill in any reset code here
	   endtask: reset_dut
	
	   task run();
	      ovm_report_info(tID, $psprintf(" %s : running", tID), OVM_MEDIUM);
	      // reset_dut(); // fill in 'reset_dut()' if needed
	      get_and_drive();
	   endtask: run
	
	   virtual function void report();
	      // fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	endclass: $1_driver
snippet ovmdriver  OVM Driver
	class ${1:ovc_name}_driver extends ovm_driver #(${2:ovc_item});
	   ${4}
	   string tID;
	   virtual interface ${3:ovc_if} vif;
	   $2 item;
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   \`ovm_component_utils_begin($1_driver)
	      \`ovm_field_object(item, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task get_and_drive();
	      forever
		begin
		   // wait(vif.reset==0);  // block until reset released
		   seq_item_port.get_next_item(item);
		   send_to_dut(item);
		   seq_item_port.item_done();
		end
	   endtask: get_and_drive
	
	   task send_to_dut(input $2 item);
	      ovm_report_info(tID, $psprintf("%s : item sent is %0s",
					     tID, item.sprint()), OVM_FULL);
	      // Send data to DUT (BFM - fill in your BFM code here)
	      #10 ;
	      #10 ;
	   endtask: send_to_dut
	
	   task reset_dut();
	      // fill in any reset code here
	   endtask: reset_dut
	
	   task run();
	      ovm_report_info(tID, $psprintf(" %s : running", tID), OVM_MEDIUM);
	      // reset_dut(); // fill in 'reset_dut()' if needed
	      get_and_drive();
	   endtask: run
	
	   virtual function void report();
	      // fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	endclass: $1_driver
snippet ovm  OVM Env
	class ${1:ovc_name}_env extends ovm_env;
	   ${2}
	   $1_agent agent0;
	   \`ovm_component_utils($1_env)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      agent0 = $1_agent::type_id::create("agent0", this);
	   endfunction: build
	
	endclass: $1_env
snippet ovm_env  OVM Env
	class ${1:ovc_name}_env extends ovm_env;
	   ${2}
	   $1_agent agent0;
	   \`ovm_component_utils($1_env)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      agent0 = $1_agent::type_id::create("agent0", this);
	   endfunction: build
	
	endclass: $1_env
snippet ovmenv  OVM Env
	class ${1:ovc_name}_env extends ovm_env;
	   ${2}
	   $1_agent agent0;
	   \`ovm_component_utils($1_env)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      agent0 = $1_agent::type_id::create("agent0", this);
	   endfunction: build
	
	endclass: $1_env
snippet ovm  OVM Interface
	interface $1(input logic clock, input logic reset);
	
	   // ToDo: Declare the interface signals corresponding to the ports
	   ${2}
	   wire [7:0] sync_tx;
	   wire [7:0] sync_rx;
	
	   logic async_sig;
	   
	   // ToDo: Define clocking blocks
	   // -- use the 'clocking' snippet
	   
	   // ToDo: Define a modport for each interface perspective
	   // -- use the 'modport' snippet
	
	endinterface: $1
snippet interface  OVM Interface
	interface $1(input logic clock, input logic reset);
	
	   // ToDo: Declare the interface signals corresponding to the ports
	   ${2}
	   wire [7:0] sync_tx;
	   wire [7:0] sync_rx;
	
	   logic async_sig;
	   
	   // ToDo: Define clocking blocks
	   // -- use the 'clocking' snippet
	   
	   // ToDo: Define a modport for each interface perspective
	   // -- use the 'modport' snippet
	
	endinterface: $1
snippet ovm  OVM Monitor
	class ${1:ovc_name}_monitor extends ovm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   ovm_analysis_port #($3) sb_post;
	
	   \`ovm_component_utils_begin($1_monitor)
	      \`ovm_field_object(trans, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(OVM_MEDIUM, ("$1_monitor: running"))
	      ovm_report_info(tID, $psprintf("%s: running", tID), OVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet ovm_monitor  OVM Monitor
	class ${1:ovc_name}_monitor extends ovm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   ovm_analysis_port #($3) sb_post;
	
	   \`ovm_component_utils_begin($1_monitor)
	      \`ovm_field_object(trans, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(OVM_MEDIUM, ("$1_monitor: running"))
	      ovm_report_info(tID, $psprintf("%s: running", tID), OVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet ovm_mon  OVM Monitor
	class ${1:ovc_name}_monitor extends ovm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   ovm_analysis_port #($3) sb_post;
	
	   \`ovm_component_utils_begin($1_monitor)
	      \`ovm_field_object(trans, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(OVM_MEDIUM, ("$1_monitor: running"))
	      ovm_report_info(tID, $psprintf("%s: running", tID), OVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet ovmmon  OVM Monitor
	class ${1:ovc_name}_monitor extends ovm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   ovm_analysis_port #($3) sb_post;
	
	   \`ovm_component_utils_begin($1_monitor)
	      \`ovm_field_object(trans, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(OVM_MEDIUM, ("$1_monitor: running"))
	      ovm_report_info(tID, $psprintf("%s: running", tID), OVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet ovmmonitor  OVM Monitor
	class ${1:ovc_name}_monitor extends ovm_monitor;
	   ${4}
	   string tID;
	   virtual interface ${2:ovc_if} vif;
	   ${3:ovc_item} trans;
	   event e_trans_collected; // event to signal transaction collected
	   // TLM port for scoreboard communication
	   //  (implement scoreboard write method if needed)
	   ovm_analysis_port #($3) sb_post;
	
	   \`ovm_component_utils_begin($1_monitor)
	      \`ovm_field_object(trans, OVM_ALL_ON)
	   \`ovm_component_utils_end
	
	   task collect_data();
	      forever begin
		 //put code to collect bus transactions here
		 #10 ;
	
		 #10 ;
	
		 ->e_trans_collected; //signal transaction collection complete
		 //post good transactions to scoreboard if enabled
		 if (sb_post.size() > 0)
		   sb_post.write(trans);
	      end;
	   endtask: collect_data
	
	   // to FIX stuff for covergroup
	   /*
	    //shell code for covergroup
	    covergroup cov_trans @ e_trans_collected;
	    cg1: coverpoint trans..$fields[2].
	    { bins MIN[]     = {0};
	    bins MAX[]     = {63};
	    }
	endgroup
	    */
	
	   task run();
	      \`message(OVM_MEDIUM, ("$1_monitor: running"))
	      ovm_report_info(tID, $psprintf("%s: running", tID), OVM_MEDIUM);
	      collect_data();
	   endtask: run
	
	   virtual function void report();
	      //fill in any reporting code if needed
	      logic dummy;
	   endfunction: report
	
	   //new() function needs to be listed last so other items defined
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      tID = get_type_name();
	      tID = tID.toupper();
	      // to FIX stuff for covergroup
	      /*
	       cov_trans = new();
	       cov_trans.set_inst_name({get_full_name(), ".cov_trans"});
	       */
	      trans = new();
	      sb_post = new("sb_post", this);
	   endfunction: new
	
	endclass: $1_monitor
snippet ovm  OVM Seq Lib
	class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`ovm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in ovm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(OVM_LOW, ("RUNNING sequence: %s", get_name()))
	      ovm_report_info(tID, $psprintf("%s: sequence Running", tID), OVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(OVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      ovm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), OVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(OVM_LOW, ("sequence: %s complete", get_name()))
	      ovm_report_info(tID, $psprintf("sequence: %s complete", tID), OVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet ovm_seq_lib  OVM Seq Lib
	class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`ovm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in ovm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(OVM_LOW, ("RUNNING sequence: %s", get_name()))
	      ovm_report_info(tID, $psprintf("%s: sequence Running", tID), OVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(OVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      ovm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), OVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(OVM_LOW, ("sequence: %s complete", get_name()))
	      ovm_report_info(tID, $psprintf("sequence: %s complete", tID), OVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet ovm_seqlib  OVM Seq Lib
	class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`ovm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in ovm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(OVM_LOW, ("RUNNING sequence: %s", get_name()))
	      ovm_report_info(tID, $psprintf("%s: sequence Running", tID), OVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(OVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      ovm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), OVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(OVM_LOW, ("sequence: %s complete", get_name()))
	      ovm_report_info(tID, $psprintf("sequence: %s complete", tID), OVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet ovmseqlib  OVM Seq Lib
	class ${1:ovc_name}_seq1 extends ovm_sequence #(${2:ovc_item});
	   ${3}
	   string tID;
	   \`ovm_sequence_utils($1_seq1, $1_sequencer)
	   // $2 trans;
	   // "req" built-in ovm_sequence class member for sequence_item
	   rand int delay1;
	   rand int delay2;
	   constraint d1 {delay1 > 55; delay1 < 125;}
	   constraint d2 {delay2 > 25; delay2 < 45;}
	
	   function new(string name = "$1_seq1");
	      super.new(name);
	      tID = get_type_name();
	      tID = tID.toupper();
	   endfunction: new
	
	   task body();
	      \`message(OVM_LOW, ("RUNNING sequence: %s", get_name()))
	      ovm_report_info(tID, $psprintf("%s: sequence Running", tID), OVM_LOW);
	      // not the best way to print, just to confirm randomization
	      \`message(OVM_LOW, ("delay1=%0d, delay2=%0d", delay1, delay2))
	      ovm_report_info(tID, $psprintf("%s: delay1=%0d, delay2=%0d",
					     tID, delay1, delay2), OVM_MEDIUM);
	      #delay1
		// dummy delay to illustrate a sequence rand variable
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay1
		// get_response(rsp); // get response if implemented
	      \`ovm_do(req) // this line sends the transaction
	      #delay2
		// get_response(rsp); // get response if implemented
	      \`message(OVM_LOW, ("sequence: %s complete", get_name()))
	      ovm_report_info(tID, $psprintf("sequence: %s complete", tID), OVM_LOW);
	   endtask: body
	
	endclass: $1_seq1
	
	//additional sequences can be included in this file
snippet ovm  OVM Sequencer
	class ${1:ovc_name}_sequencer extends ovm_sequencer #(${2:ovc_item});
	   ${3}
	   \`ovm_sequencer_utils($1_sequencer)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      \`ovm_update_sequence_lib_and_item($2)
	   endfunction: new
	
	endclass: $1_sequencer
snippet ovm_sequencer  OVM Sequencer
	class ${1:ovc_name}_sequencer extends ovm_sequencer #(${2:ovc_item});
	   ${3}
	   \`ovm_sequencer_utils($1_sequencer)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      \`ovm_update_sequence_lib_and_item($2)
	   endfunction: new
	
	endclass: $1_sequencer
snippet ovmsequencer  OVM Sequencer
	class ${1:ovc_name}_sequencer extends ovm_sequencer #(${2:ovc_item});
	   ${3}
	   \`ovm_sequencer_utils($1_sequencer)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	      \`ovm_update_sequence_lib_and_item($2)
	   endfunction: new
	
	endclass: $1_sequencer
snippet ovm  OVM Sve
	class sve extends ovm_env;
	   ${2}
	   ${1:ovc_name}_env env0;
	   \`ovm_component_utils(sve)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      env0 = $1_env::type_id::create("env0", this);
	   endfunction: build
	
	   virtual function void connect();
	      env0.agent0.assign_vif(top.if0);
	   endfunction: connect
	endclass: sve
snippet ovm_sve  OVM Sve
	class sve extends ovm_env;
	   ${2}
	   ${1:ovc_name}_env env0;
	   \`ovm_component_utils(sve)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      env0 = $1_env::type_id::create("env0", this);
	   endfunction: build
	
	   virtual function void connect();
	      env0.agent0.assign_vif(top.if0);
	   endfunction: connect
	endclass: sve
snippet ovmsve  OVM Sve
	class sve extends ovm_env;
	   ${2}
	   ${1:ovc_name}_env env0;
	   \`ovm_component_utils(sve)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      env0 = $1_env::type_id::create("env0", this);
	   endfunction: build
	
	   virtual function void connect();
	      env0.agent0.assign_vif(top.if0);
	   endfunction: connect
	endclass: sve
snippet ovm  OVM Test
	class test1 extends ovm_test;
	   ${2}
	   sve sve0;
	   \`ovm_component_utils(test1)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      set_config_int("sve0.env0.agent0.sequencer", "count", 2);
	      set_config_int("sve0.env0.agent0", "is_active", OVM_ACTIVE);
	      set_config_string("sve0.env0.agent0.sequencer",
				"default_sequence", "${1:ovc_name}_seq1");
	      sve0 = sve::type_id::create("sve0", this);
	   endfunction: build
	
	   task run();
	      \`message(OVM_LOW, ("test1 running..."))
	      ovm_top.print_topology();
	      #10000
		//delay is simple "end of test" mechanism
		//use objections in sequences for better "end of test" detection
		\`message(OVM_LOW, ("User activated end of simulation"))
	      global_stop_request();
	   endtask: run
	
	endclass: test1
snippet ovm_test  OVM Test
	class test1 extends ovm_test;
	   ${2}
	   sve sve0;
	   \`ovm_component_utils(test1)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      set_config_int("sve0.env0.agent0.sequencer", "count", 2);
	      set_config_int("sve0.env0.agent0", "is_active", OVM_ACTIVE);
	      set_config_string("sve0.env0.agent0.sequencer",
				"default_sequence", "${1:ovc_name}_seq1");
	      sve0 = sve::type_id::create("sve0", this);
	   endfunction: build
	
	   task run();
	      \`message(OVM_LOW, ("test1 running..."))
	      ovm_top.print_topology();
	      #10000
		//delay is simple "end of test" mechanism
		//use objections in sequences for better "end of test" detection
		\`message(OVM_LOW, ("User activated end of simulation"))
	      global_stop_request();
	   endtask: run
	
	endclass: test1
snippet ovmtest  OVM Test
	class test1 extends ovm_test;
	   ${2}
	   sve sve0;
	   \`ovm_component_utils(test1)
	
	   function new(string name, ovm_component parent);
	      super.new(name, parent);
	   endfunction: new
	
	   virtual function void build();
	      super.build();
	      set_config_int("sve0.env0.agent0.sequencer", "count", 2);
	      set_config_int("sve0.env0.agent0", "is_active", OVM_ACTIVE);
	      set_config_string("sve0.env0.agent0.sequencer",
				"default_sequence", "${1:ovc_name}_seq1");
	      sve0 = sve::type_id::create("sve0", this);
	   endfunction: build
	
	   task run();
	      \`message(OVM_LOW, ("test1 running..."))
	      ovm_top.print_topology();
	      #10000
		//delay is simple "end of test" mechanism
		//use objections in sequences for better "end of test" detection
		\`message(OVM_LOW, ("User activated end of simulation"))
	      global_stop_request();
	   endtask: run
	
	endclass: test1
snippet ovm  OVM Top
	\`include "ovm.svh"
	\`include "${1:ovc_name}_inc.svh"
	\`include "sve.sv"
	\`include "test1.sv"
	module top();
	   ${3}
	   logic clock;
	   logic reset;
	
	   ${2:ovc_if} if0(clock, reset); // instantiate ovc interface
	
	   initial
	     begin
		run_test();
	     end
	
	   always #10 clock = ~clock;
	
	   initial
	     begin
		clock = 0;
		reset = 1; // active high reset for this example
		#75 reset = 0;
	     end
	
	   // instantiate and connect dut to interface(s) here
	
	endmodule: top
snippet ovm_top  OVM Top
	\`include "ovm.svh"
	\`include "${1:ovc_name}_inc.svh"
	\`include "sve.sv"
	\`include "test1.sv"
	module top();
	   ${3}
	   logic clock;
	   logic reset;
	
	   ${2:ovc_if} if0(clock, reset); // instantiate ovc interface
	
	   initial
	     begin
		run_test();
	     end
	
	   always #10 clock = ~clock;
	
	   initial
	     begin
		clock = 0;
		reset = 1; // active high reset for this example
		#75 reset = 0;
	     end
	
	   // instantiate and connect dut to interface(s) here
	
	endmodule: top
snippet ovmtop  OVM Top
	\`include "ovm.svh"
	\`include "${1:ovc_name}_inc.svh"
	\`include "sve.sv"
	\`include "test1.sv"
	module top();
	   ${3}
	   logic clock;
	   logic reset;
	
	   ${2:ovc_if} if0(clock, reset); // instantiate ovc interface
	
	   initial
	     begin
		run_test();
	     end
	
	   always #10 clock = ~clock;
	
	   initial
	     begin
		clock = 0;
		reset = 1; // active high reset for this example
		#75 reset = 0;
	     end
	
	   // instantiate and connect dut to interface(s) here
	
	endmodule: top
